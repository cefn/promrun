#!/usr/bin/python3

"""Based on an export file generated by PyOPN, to extract the low-level records from an Opticon barcode scanner for parkrun"""
import sys
from dateutil import parser


class Record(object):
    barcode = None
    moment = None
    def __str__(self):
        timeDiff = abs(int((self.moment - self.nearest.moment).total_seconds()))
        return f"{self.barcode} {self.nearest.barcode} {timeDiff}s {self.moment.time()} {self.nearest.moment.time()}"

positions = []
athletes = []
with open('pyopn_export.txt') as sourceFile:
    lastMoment = None
    passed = None
    while True:
        line = sourceFile.readline()
        if not line:
            break
        else:
            fields = line.split(" ")
            if line.startswith("[3]"):
                fields = line.split(" ")
                barcode = fields[1]
                moment = fields[2] + " " + fields[3]
                moment = parser.parse(moment)
                record = Record()
                record.barcode = barcode
                record.moment = moment
                if barcode.startswith("P"):
                    positions.append(record)
                    record.category = "position"
                elif barcode.startswith("A"):
                    athletes.append(record)
                    record.category = "athlete"


timeOrder = lambda r:r.moment
codeOrder = lambda r:r.barcode


records = sorted(athletes + positions, key=timeOrder)
athletes = sorted(athletes, key=timeOrder)
positions = sorted(positions, key=timeOrder)

def createDelayCalculator(ref):
    return lambda other:abs( (ref.moment - other.moment).total_seconds())


def decorateWithNearest(items):    
    for (index, record) in enumerate(items):
        # get neighbouring scans
        prevList = [items[index - 1]] if index > 0 else [] 
        nextList = [items[index + 1]] if index + 1 < len(items) else []
        # get compatible scans - athletes only match positions + vice versa
        compatible = lambda match: match.category != record.category  
        prevList = list(filter(compatible, prevList))
        nextList = list(filter(compatible, nextList))
        matches = prevList + nextList
        minSecondsApart = sys.maxsize
        # count matches and choose nearest
        if len(matches) > 0:
            for match in matches : 
                secondsApart = abs(int((record.moment - match.moment).total_seconds()))
                if secondsApart < minSecondsApart:
                    record.nearest = match
                    record.separation = secondsApart
                    minSecondsApart = secondsApart
        else:
            # no compatible neighbour 
            record.nearest = None
            
decorateWithNearest(records)

for athlete in athletes:
    if athlete.nearest.nearest == athlete:
        print(athlete, "Mutual")
    else:
        print(athlete, "\nConflict:\t", athlete.nearest)
    
